There are two kinds of monitoring files: map files and log files. Map files records the mapping of all tasks among workers. Each worker has one log file recording scheduling events. Information of each event is represented by one entry in the log file. Each entry ends with "#". (This is because the efficiency of the monitoring framework. To be read easily, "#" can be replaced by "\n")
There are 2 kinds of events: worker events, task events.
- Worker events:
	+ Worker started: Entry = <timestamp> S
	+ Worker waited: Entry = <timestamp> W <waiting time>
	+ Worker ended: Entry = <timestamp> E
- Task events:
	+ Task blocked: Entry = <timestamp> <blocked by> <task id> <execution time> <stream trace> | <message trace>
	+ Task ended: Entry = <timestamp> Z <task id> <execution time> <create time> <stream trace> | <message trace>
<blocked by>: "I" =  task is blocked by input. "O" = task blocked by output
<execution time> execution time since the last dispatch

Stream trace: information of streams on which the task operates
<stream trace> = {<stream entry>; }*
<stream entry> = <stream id>,<mode>,<#items>,<flags>
<mode>: "r" = task reads from stream, "w" = task writes to stream
<#items>: number of messages read from/written to stream (depending on the mode)
<flags>:  Activity fags. If no fag is set, the pattern is '--- '.  The first flag ('? ' if set) indicates that the task is blocked on that stream. The second flag '! ' indicates, that reading/writing (dependent on mode) unblocked the task on the other side of the stream.The third flag '* ' indicates that items have been read/written to the stream.

Message trace: information of messages which task consumes/produces
<message trace> = {<message entry>;}*
<message entry> = <timestamp> <io> <message id>
<timestamp>: time at which the message is consumed/produced
<io>: "I" = message is an input (consumed by the task), "O" message is an output (produced by the task)


